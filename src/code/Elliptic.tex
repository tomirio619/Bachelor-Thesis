\begin{minted}[linenos=true, fontsize=\footnotesize, breaklines=true]{python}
def PlotEllipticOutliers(rawPositions, ID, timestmp):
    """
    This method is used for outlier detection on a straight track.
    Uses the EllipticEnvelope object from Scikit-learn
    :param rawPositions:    The raw GPS positions
    :param ID:              The ID of the user
    :param timestmp:        The timestamp
    """
    folder = "out/"
    plotDir = folder + "plots/Walking Test"

    lats = []
    longs = []
    timestamps = []
    for pos in rawPositions:
        lat = pos["latitude"]
        long = pos["longitude"]
        timestamp = pos["timestamp"]
        lats.append(lat)
        longs.append(long)
        timestamps.append(timestamp)

    # writeToFile(ID, "output", lats, longs)
    classifiers = {
        "Robust Covariance Estimator": EllipticEnvelope(contamination=0.08, support_fraction=0.8)
    }
    alpha = 0.5
    linewidth = 0.15

    classifierName = "Robust Covariance Estimator"
    classifier = classifiers[classifierName]
    X = zip(lats, longs)
    xx1, yy1 = np.meshgrid(np.linspace(min(lats), max(lats), 1000), np.linspace(min(longs), max(longs), 1000))
    classifier.fit(X)
    Z1 = classifier.decision_function(np.c_[xx1.ravel(), yy1.ravel()])
    Z1 = Z1.reshape(xx1.shape)
    CS = plt.contour(xx1, yy1, Z1, levels=[0], linewidths=1, colors="g")
    CS.collections[0].set_label(classifierName)
    plt.scatter(lats, longs, s=50, alpha=alpha, linewidth=linewidth, edgecolor=almost_black, color="steelblue",
                label="GPS coordinate")
    plt.autoscale(enable=True, axis="both")
    filteredPositions = []

    for lat, long, timestamp in zip(lats, longs, timestamps):
        z = classifier.decision_function(np.c_[lat, long])
        if z > 0:  # Check if coordinate (lat, long) is within the ellipse
            filteredPositions.append((lat, long, timestamp))

    y = zip(*filteredPositions)[0]  # the latitudes
    x = zip(*filteredPositions)[1]  # the longitudes
    t = zip(*filteredPositions)[2]  # the timestamps

    x2, y2, newx2, newy2 = smooth(y, x, t)
    plt.plot(y2, x2, label="Linear Interpolation")
    totalDistance = calcDistanceWalked(newy2, newx2)

    plt.plot(newy2, newx2, label="Savgol Filter", color="r")
    plt.title("Timestamp: %s\n Calculated distance: %i meters" % (timestmp, totalDistance))
    plt.xlabel("Latitude")
    plt.ylabel("Longitude")
    fancyPlot()
    writeToPdf(ID, plotDir)

\end{minted}